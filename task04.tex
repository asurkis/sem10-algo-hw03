\section{Задача 4}
Даны число $K$ и изначально пустая последовательность. Вам поступает $n$ запросов, каждый одного из двух типов:
\begin{itemize}
    \item \texttt{append(x)} --- дописать элемент $x$ в конец последовательности
    \item \texttt{rev()} ---
    развернуть $K$ последних элементов последовательности (если в данный момент их всего меньше $K$, то
    развернуть всю последовательность).
\end{itemize}

Вам нужно один раз после всех запросов вывести получившуюся последовательность.
\begin{enumerate}[label=(\alph*)]
    \item $\O(n \log{n})$
    \item $\O(n)$
\end{enumerate}

\subsection{Решение}
\subsubsection{Пункт~(a)}
Будем хранить нашу последовательность в виде АВЛ-дерева.
В каждой вершине $v$ дополнительно будем хранить информацию $r(v)$, нужно ли развернуть поддерево этой вершины целиком.
$P(v)$ --- левый ребёнок, $S(v)$ --- правый ребёнок.
Назовём нормализацией вершины следующие действия:
\begin{algorithmic}
    \If{$r(v)$}
        \State $r(P(v)) \gets \lnot r(P(v))$
        \State $r(S(v)) \gets \lnot r(S(v))$
        \State \Call{swap}{$P(v), S(v)$}
        \State $r(v) \gets 0$
    \EndIf
    \LComment{$r(v) = 0 \quad \O(1)$, баланс дерева не нарушается}
\end{algorithmic}

Будем проводить нормализацию при \emph{каждом} спуске в вершину, до перехода к её детям.

Тогда вставка \texttt{append(x)} --- это обычная вставка (с учётом нормализации)
самого правого элемента $x$ в АВЛ-дерево.
$\O(\log L)$ на запрос, где $L$ --- текущая длина последовательности.

Разворачивание \texttt{rev()}:
\begin{algorithmic}
    \LComment{Применяем нормализацию также и в \textsc{split} и \textsc{merge}}
    \State $T_1, T_2 \gets$ \Call{split}{корень, индекс с конца не больше $K$}
    \Comment{$\O(\log L)$}
    \LComment{
        Поскольку до этого мы нормализовывали вершину $T_2$,
        то эквивалентно $r(T_2) \gets 1$}
    \State $r(T_2) \gets \lnot r(T_2)$
    \Comment{$\O(1)$}
    \State $T \gets$ \Call{merge}{$T_1, T_2$}
    \Comment{$\O(\log L)$}
\end{algorithmic}

Тогда разворачивание --- тоже $\O(\log L)$ на запрос.

Вывод итоговой последовательности --- проход по дереву с нормализацией.
Он производится за $\O(L)$.

Тогда в результате весь алгоритм требует $n \cdot \O(\log L) + \O(L) \subset \O(n \log n)$
времени.

Искомый алгоритм найден.

Также решение из задачи~7 --- более общий вариант этого решения.
